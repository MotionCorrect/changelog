#!/usr/bin/env python
import sys, io, time
import logging
import datetime
import json

import requests

logger = logging.getLogger(__name__)

class GithubAPI(object):
    """
    Simple wrapper around the github API that respects rate limiting and supports authentication.
    """
    def __init__(self, repo_url, token=None):
        self._token = token
        self.repo_url = repo_url
        self.api_url_prefix = "https://api.github.com"
        self.check_rate_limit()

    def check_rate_limit(self):
        """
        API limits reset every hour so there is no point in spacing the requests over time
        as the delays will make the script unuseable. Instead check monitor the requests
        remaining and notify user accordingly.
        It is recommended to use a PAT (personal access token) as this will increase the api
        limit for some resources.
        """
        logger.info("Checking API rate limits:")

        url = f"{self.api_url_prefix}/rate_limit"
        r = self.request(url).json()

        logger.debug(f"rate_limits: {r}")

        core_api = r['resources']['core']
        search_api = r['resources']['search']

        logger.info(f"Core api limit={core_api['limit']} remaining={core_api['remaining']} reset={datetime.datetime.fromtimestamp(core_api['reset'])}")
        logger.info(f"Search api limit={search_api['limit']} remaining={search_api['remaining']} reset={datetime.datetime.fromtimestamp(search_api['reset'])}")

        if core_api['remaining'] == 0:
            raise ValueError(f"Core API limit reached! Retry at {datetime.datetime.fromtimestamp(core_api['reset'])}")

        if search_api['remaining'] == 0:
            raise ValueError(f"Search API limit reached! Retry at {datetime.datetime.fromtimestamp(search_api['reset'])}")


    def request(self, url, method="GET", headers=None, params=None, data=None):
        headers = headers or {}
        if self._token:
            headers['Authorization'] = f"token {self._token}"
        headers['Accept'] = 'application/json'

        def callback(response, *args, **kwargs):
            if not response.ok:
                logger.error(f"Got a non 200 code from server: {response.status_code}: {response.json()}")
                raise RuntimeError(response.status_code, response.json())

            limit = response.headers.get('X-RateLimit-Limit')
            remaining = response.headers.get('X-RateLimit-Limit')
            reset = response.headers.get('X-RateLimit-Reset')

            logger.debug(f"api rate limit stats: limit={limit}, remaining={remaining}, reset={datetime.datetime.fromtimestamp(int(reset))}")

            if remaining == 0:
                raise ValueError(f"API limit reached! Retry at {datetime.datetime.fromtimestamp(reset)} or use an authentication token!")

        return requests.request(
            method=method,
            url=url,
            headers=headers,
            params=params,
            data=data,
            hooks={'response': callback}
        )

    def get_latest_milestone(self):
        """
        Get info about the latest milestone currently open in issues.
        """
        url = f"{self.api_url_prefix}/repos/{self.repo_url}/milestones"
        r = self.request(url).json()

        logger.debug(f"Open milestones found: {r}")
        if len(r) == 0:
            raise ValueError("No open milestone was found on github.")
        elif len(r) > 1:
            logger.info(f"Found multiple open milestones on github. Using latest: {r[0]}")
        return r[0]

    def get_tags_compare_url(self, new_tag):
        """
        Return the Github URL comparing the last tag with the new_tag.
        """
        url = f"{self.api_url_prefix}/repos/{self.repo_url}/releases"
        r = self.request(url).json()
        previous_tag = r[0]['tag_name']
        return f"https://github.com/{self.repo_url}/compare/{previous_tag}...{new_tag}"

    def search(self, milestone, label=None):
        """
        Return a list of merged pull requests linked to the milestone and label provided.
        """
        url = f"{self.api_url_prefix}/search/issues"
        query = f'milestone:"{milestone}" is:pr repo:{self.repo_url} state:closed is:merged'
        if label:
            query += f' label:{label}'
        payload = {'q': query}
        r = self.request(url=url, params=payload).json()
        logger.info(f"Milestone: {milestone}, Label: {label}, Count: {r['total_count']}")
        return r


def get_sct_function_from_label(dict_labels=''):
    """
    Return a csv string with a list of labels that corresponds to SCT functions exposed to the user (contains "sct_")
    :param dict_labels: dictionary of labels generated by Github
    :return: labels_list: list of labels
    """
    labels_list = []
    for label in dict_labels:
        # check if label contains sct
        if "sct_" in label['name']:
            labels_list.append(label['name'])
    return labels_list


def check_compatibility(dict_labels):
    """
    Check if label "compatibility" is included. If it is, output a string with warning about broken compatibility.
    Otherwise, output an empty string.
    :param dict_labels: dictionary of labels generated by Github
    :return: str: String with warning of broken compatibility. Or empty otherwise.
    """
    for label in dict_labels:
        if 'compatibility' in label['name']:
            return '**WARNING: Breaks compatibility with previous version!**'
    else:
        return ''

def get_parser():
    import argparse

    parser = argparse.ArgumentParser(
     description="Changelog generator script",
    )

    parser.add_argument("--log-level",
     default="INFO",
     help="Logging level (eg. INFO, see Python logging docs)",
    )

    parser.add_argument("--repo-url",
     required=True,
     help="Repository url in the format <GITHUB_USER/REPO_NAME>. Example: neuropoly/spinalcordtoolbox",
    )

    parser.add_argument("--token",
     help="Github API personal access token for authentication. See https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token",
    )

    return parser

def main():
    parser = get_parser()
    args = parser.parse_args()

    logging.basicConfig(stream=sys.stdout, level=args.log_level, format="%(levelname)s %(message)s")

    api = GithubAPI(repo_url=args.repo_url, token=args.token)
    user, repo = args.repo_url.split('/')

    milestone = api.get_latest_milestone()
    tag = milestone['title'].split()[-1]

    lines = [
        f"## {tag} ({datetime.date.today()})",
        f"[View detailed changelog]({api.get_tags_compare_url(tag)})"
    ]

    changelog_pr = set()

    for label in ['bug', 'enhancement', 'feature', 'documentation', 'installation', 'testing']:
        pulls = api.search(milestone['title'], label)
        items = pulls.get('items')
        if items:
            lines.append('\n**{}**\n'.format(label.upper()))
            changelog_pr = changelog_pr.union(set([x['html_url'] for x in items]))
            for x in pulls.get('items'):
                items = [" - **%s:** %s. %s[View pull request](%s)" % (",".join(get_sct_function_from_label(x['labels'])),
                                                                x['title'],
                                                                check_compatibility(x['labels']),
                                                                x['html_url'])]
                if (len(get_sct_function_from_label(x['labels'])) == 0):
                    items[0] = items[0].replace("**:** ","")
                lines.extend(items)

    logger.info('Total number of pull requests with label: %d', len(changelog_pr))
    all_pr = set([x['html_url'] for x in api.search(milestone['title'])['items']])
    diff_pr = all_pr - changelog_pr
    for diff in diff_pr:
        logger.warning('Pull request not labeled: %s', diff)

    filename = f"{user}_{repo}_changelog.{milestone['number']}.md"
    with io.open(filename, "w") as changelog:
        changelog.write('\n'.join(lines))
    logger.info(f"Changelog saved in {filename}")

    return 0


if __name__ == '__main__':
    raise SystemExit(main())


